# ROS2 CHEATSHEET

## Lets start with the ROS2 File System

```
ros_ws/                       # Root of your ROS 2 workspace
├── build/                    # Build artifacts (generated by colcon)
├── install/                  # Install space (generated by colcon)
├── log/                      # Log files
├── src/                      # Source code directory
│   ├── your_package/         # Your ROS 2 package
│   │   ├── setup.py          # python build configuration
│   │   ├── setup.cfg   
│   │   ├── package.xml       # Package manifest
│   │   ├── your_package/     # Source code directory
│   │   │   ├── your_node.py  # Your Python node script
│   │   ├── resource/
│   │   ├── launch/           # Launch files
│   │   ├── urdf/             # urdf files
│   │   ├── test/
```

Here's a brief explanation of each directory and important files:

#### Important Directories
- `src/`: This is where you'll place your ROS 2 packages. Each package is a directory containing executables with different functionalities or programs.

- `your_package/`: This is your ROS 2 package's directory. It contains your package's source code, launch files, scripts, and other resources.

- `your_package/your_package`: This directory holds your Python source code files.

- `setup.py`: This file contains build instructions for python and directs ROS to your executable scripts.

- `your_node.py`: This is an example Python node script. You can place your ROS 2 nodes here.

- `launch/`: This directory is used to store ROS 2 launch files, which allow you to start multiple nodes with specific parameters in a single command.

- `urdf/`: This directory is used to store urdf files that describe the structure and physical properties of a robot.

## ROS 2 Workspace and package

1. **Create a Workspace**:
   Open a terminal and create a directory for your ROS 2 workspace. Let's call it `ros_ws`:
   ```bash
   mkdir -p ros_ws/src
   cd ros_ws
   ```

2. **Build Your Workspace**:
   Now, you'll use the `colcon` build tool to build your workspace:

   ```bash
   colcon build
   ```

3. **Create a Package**:
   To create a ROS 2 Python package:
   ```bash
   cd src
   ros2 pkg create --build-type ament_python <package_name>
   cd ..
   ```

   Replace `<package_name>` with the desired name for your package.

4. **Develop Your Package**:
   Open Vscode with the following command:
   ```bash
   code src
   ```
   Now that Vscode is open create a python file with a `<script_name>`.py extension in the folder `<package_name>/<package_name>`.

5. **Modify setup.py**:
    Open setup.py and add your script to console_scripts in the following manner:
    ```python
    'console_scripts': [
            '<executable_name> = <package_name>.<script_name>:main'
        ]
    ```

6. **Making your script an executable**
   Return to the terminal window and execute the following command:
   ```bash
   chmod +x src/<package_name>/<package_name>/<script_name>.py
   ```

7. **Build the Package**:
   Go back to your workspace root and build the package with symlink:
   ```bash
   colcon build --symlink-install
   ```

8. **Source**:
   After building, source your workspace again:
   ```bash
   source install/setup.bash
   ```


9. **Run a Node**:
    Now you can run a Python node from your package:
    ```bash
    ros2 run <package_name> <executable_name>
    ```

You've created a ROS 2 workspace for Python development and built a basic package with a Python executable node.

## ROS2 Basic nodes

### Section 1: Imports
   the first thing in every new python file must be the imports these are the must needed imports to which you can add as per your requirements.
   ```python
   import rclpy
   from rclpy.node import Node
   ```

### Section 2: Main Function
   Every python file must also have the main function as this is whats called everytime this executable is called
   ```python
   def main(args=None):
      rclpy.init(args=args)
      node = NodeName()
      rclpy.spin(node)
      rclpy.shutdown()
   ```
   1. **`rclpy.init(args=args)`**: Initializes the ROS 2 context.

   2. **`node = NodeName()`**: Creates a node instance to manage ROS 2 activities.

   3. **`rclpy.spin(node)`**: Processes incoming callbacks (messages, services) and keeps the node active.(basically prevents the node from terminating instantly)

   4. **`rclpy.shutdown()`**: Properly shuts down the ROS 2 context and cleans up resources.

### Section 3: Class Definitions

#### Publisher Node
Publishes messages on a specific topic for other nodes to receive.
```python
class PublisherNode(Node):
    def __init__(self):
        super().__init__('publisher_node')
        self.publisher_ = self.create_publisher(String, 'topic_name', 10) #put the datatype of the data your publishing
        self.timer = self.create_timer(1, self.timer_callback)
        self.get_logger().info('Publisher node initialized')

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello, ROS 2!'
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: %s' % msg.data)
```

#### Subscriber Node
Subscribes to a specific topic and receives messages published by other nodes.

```python
class SubscriberNode(Node):
    def __init__(self):
        super().__init__('subscriber_node')
        self.subscription = self.create_subscription(
            String, #put the datatype of what your subscribing to
            'topic_name',
            self.listener_callback,
            10
        )
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):  
      # this function is called a callback function and will run everytime a message is recieved on the topic
        self.get_logger().info('Received: %s' % msg.data)
```

#### Service Node
Provides a service that other nodes can request and receive a response from, is essentially a function with an input and an output.
```python
class ServiceNode(Node):
    def __init__(self):
        super().__init__('service_node')
        self.service = self.create_service(
            Empty, # replace Empty with your service type
            'service_name',
            self.service_callback
        )

    def service_callback(self, request, response):
        self.get_logger().info('Service request received')
        return response
```

#### Client Node
Calls a service provided by another node and receives the response, basically like calling a function.
```python
class ClientNode(Node):
    def __init__(self):
        super().__init__('client_node')
        self.client = self.create_client(Empty, 'service_name') # replace Empty with your service type

        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting...')
        self.request = Empty.Request()

    def send_request(self):
        self.future = self.client.call_async(self.request)
```




This cheatsheet covers the basic concepts of ROS 2, including setting up publishers, subscribers, services, and clients.

Remember to replace `'topic_name'` and `'service_name'` with your desired topic and service names. This cheatsheet provides a foundation for understanding communication between nodes in ROS 2.

## Launch Files

### 1. Create a Launch Directory:
Inside your ROS 2 package, create a directory called `launch` to store your launch files:
```plaintext
ros2_ws/
├── src/
│   ├── your_package/
│   │   ├── launch/                 <-- Create this directory
│   │   │   ├── your_file.launch.py <-- Your launch file
```

### 2. Define Your Launch File:

Create a Python launch file (e.g., `your_file.launch.py`) in the `launch` directory:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    # define the launch description
    ld = LaunchDescription()

    #define the action
    rviz_node = Node(
        package= "rviz2",     # name of the package you want to launch
        executable= "rviz2",  # name of the executable
        name= "rviz2",        # name you want to give this node
        output= "screen",
    )

    # add the action   
    ld.add_action(rviz_node)
    return ld
```

### 3. Add PATH to launch file in setup.py

Add the last line in your data_files in setup.py
```python
data_files=[
   ('share/ament_index/resource_index/packages',
      ['resource/' + package_name]),
   ('share/' + package_name, ['package.xml']),
   (os.path.join('share', package_name), glob.glob('launch/*.launch.py')) #<---- add this line
]
```

### 4. Running the Launch File:

Use the `ros2 launch` command to run your launch file:

```bash
ros2 launch your_package your_file.launch.py
```

You can expand upon this foundation to launch multiple nodes, set additional parameters, and add more advanced features to your launch files.

Certainly! Here's a short cheat sheet on working with URDF (Unified Robot Description Format) in ROS 2:

## URDF

### 1. Create a URDF Directory:

Inside your ROS 2 package, create a directory called `urdf` to store your URDF files:
```plaintext
ros2_ws/
├── src/
│   ├── your_package/
│   │   ├── urdf/                  <-- Create this directory
│   │   │   ├── your_robot.urdf    <-- Your URDF file
```

### 2. Define Your URDF File:

Create a URDF file (e.g., `your_robot.urdf`) in the `urdf` directory:

```xml
<?xml version="1.0"?>
<robot name="your_robot">

  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.2 0.1 0.05"/>
      </geometry>
    </visual>
  </link>

  <joint name="joint_name" type="fixed">
    <parent link="base_link"/>
    <child link="child_link"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </joint>

  <link name="child_link">
    <visual>
      <geometry>
        <cylinder radius="0.05" length="0.3"/>
      </geometry>
    </visual>
  </link>

</robot>
```

### 3. URDF Elements:

- **`<robot>`**: Root element that encapsulates the entire robot description.
- **`<link>`**: Represents a physical component of the robot (e.g., links, frames).
- **`<joint>`**: Represents a joint connecting two links.
- **`<visual>`**: Describes the visual representation of a link.
- **`<geometry>`**: Specifies the shape and dimensions of the link.

### 4. Visualizing the URDF:

Use the ROS 2 `robot_state_publisher` package to visualize your URDF in tools like RViz:

1. Add `robot_state_publisher` dependency in your package's `package.xml`.
2. Create a launch file to load your URDF:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    urdf_path = 'ros_ws/src/<package_name>/urdf/<urdf_file>.urdf'
    ld = LaunchDescription()
    robot_state_node = Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            output='screen',
            arguments=[urdf_path]  # Replace with your URDF file path
        )
    ld.add_action(robot_state_node)
    return ld
```

### 5. Launch the Visualization:

```bash
ros2 launch your_package visualize_urdf.launch.py
```

This  a quick overview of working with URDF files in ROS 2. You can create more complex robot descriptions using different link and joint types, visualize them, and integrate them.
